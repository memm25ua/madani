---
import "../styles/global.css";
interface Project {
  name: string;
  description: string;
  image: string | null;
  thumbnail: string | null;
  url: string | null;
}
const { projects } = Astro.props as { projects: Project[] };
---

<style>
  html,
  body {
    margin: 0;
    padding: 0;
  }
  .gallery {
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    position: relative;
    background: #fff;
  }
  .screen {
    position: absolute;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: row;
    will-change: transform;
    pointer-events: none;
    visibility: hidden;
    color: #111;
    transition: flex-direction 0.3s;
  }
  .screen.reverse {
    flex-direction: row-reverse;
  }
  .visible {
    visibility: visible;
  }

  .panel {
    height: 100%;
    width: 50vw;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition:
      width 0.3s,
      height 0.3s;
  }
  .imagePanel {
    background-color: #111;
    background-size: cover;
    background-position: center;
    overflow: hidden;
  }
  .imageInner {
    position: absolute;
    inset: 0;
    background-size: cover;
    background-position: center;
    will-change: transform;
    transform: translateZ(0);
  }
  .thumbPanel {
    background: #fff;
  }

  .thumbBox {
    width: 160px;
    height: 160px;
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    pointer-events: auto;
  }
  .thumbBox img {
    max-width: 80%;
    max-height: 80%;
    object-fit: contain;
  }
  .caption {
    position: absolute;
    left: 24px;
    bottom: 24px;
    font-size: 28px;
    font-weight: 600;
    letter-spacing: 0.02em;
    color: #111;
    opacity: 0;
  }
  .index {
    position: absolute;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 22px;
    font-weight: 600;
    opacity: 0;
  }
  .titleRight {
    position: absolute;
    bottom: 24px;
    right: 24px;
    font-size: 28px;
    font-weight: 600;
    opacity: 0;
  }
  /* Distortion filter application */
  .distort {
    filter: url("#textDistortion");
  }

  /* context7: Responsive mobile styles for column layout and hide thumbnail */
  @media (max-width: 768px) {
    .screen,
    .screen.reverse {
      flex-direction: column !important;
      width: 100vw;
      height: 100vh;
    }
    .panel {
      width: 100vw;
      height: 50vh;
      min-height: 200px;
      min-width: 0;
    }
    .imagePanel {
      min-height: 40vh;
      height: 50vh;
      width: 100vw;
    }
    .thumbPanel {
      min-height: 40vh;
      height: 50vh;
      width: 100vw;
    }
    .caption,
    .titleRight {
      position: static;
      text-align: center;
      margin-top: 16px;
      margin-bottom: 0;
      left: auto;
      right: auto;
      bottom: auto;
      font-size: 22px;
    }
    .index {
      position: static;
      transform: none;
      margin-top: 8px;
      font-size: 18px;
    }
    .thumbBox {
      display: none !important;
    }
  }
</style>

<div class="gallery">
  {
    projects?.map((p, i) => {
      const bg = p.image ?? "";
      const thumb = p.thumbnail ?? "/favicon.svg";
      const isReverse = i % 2 === 1;
      return (
        <div
          class={`screen ${i === 0 ? "visible" : ""} ${isReverse ? "reverse" : ""}`}
          id={`screen-${i}`}
        >
          <div class="panel imagePanel">
            <div class="imageInner" style={`background-image: url('${bg}');`} />
          </div>
          <div class="panel thumbPanel">
            <div class="thumbBox">
              {p.url ? (
                <a
                  href={p.url}
                  target="_blank"
                  rel="noreferrer"
                  style="pointer-events:auto;"
                >
                  <img src={thumb} alt={`${p.name} thumbnail`} />
                </a>
              ) : (
                <img src={thumb} alt={`${p.name} thumbnail`} />
              )}
            </div>
            {isReverse ? (
              <div class="titleRight">{p.name}</div>
            ) : (
              <div class="caption">{p.name}</div>
            )}
            <div class="index">{String(i + 1).padStart(2, "0")}</div>
          </div>
        </div>
      );
    })
  }
</div>

<!-- SVG filter for wave/liquid distortion -->
<svg
  xmlns="http://www.w3.org/2000/svg"
  style="position:absolute;width:0;height:0;overflow:hidden"
>
  <filter id="textDistortion" x="-20%" y="-20%" width="140%" height="140%">
    <feTurbulence
      id="td-turb"
      type="fractalNoise"
      baseFrequency="0.02"
      numOctaves="2"
      seed="2"
      result="noise"></feTurbulence>
    <feDisplacementMap
      id="td-disp"
      in="SourceGraphic"
      in2="noise"
      scale="0"
      xChannelSelector="R"
      yChannelSelector="G"></feDisplacementMap>
  </filter>
  <!-- more filters could be declared here -->
</svg>

<script>
  import { gsap } from "gsap";
  import { CustomEase } from "gsap/CustomEase";
  import { Observer } from "gsap/Observer";

  gsap.registerPlugin(Observer);
  gsap.registerPlugin(CustomEase);

  CustomEase.create("superFastSlowEnd", "M0,0 C0.1,1 0.1,1 1,1");
  // Elige aquí el ease para el snap (puedes cambiar entre superOut1..5)
  const snapEase = "superFastSlowEnd";

  const sections = gsap.utils.toArray(".screen") as HTMLElement[];
  const wrapIndex = gsap.utils.wrap(0, sections.length);
  const imageInners = sections.map(
    (s) => s.querySelector(".imageInner") as HTMLElement
  );

  // Distortion filter nodes
  const turb = document.getElementById(
    "td-turb"
  ) as SVGFETurbulenceElement | null;
  const disp = document.getElementById(
    "td-disp"
  ) as SVGFEDisplacementMapElement | null;
  // Per-section tween registry and visibility state for text
  const activeDistortTweens = new Map<number, gsap.core.Tween>();
  const textShown = sections.map(() => false);

  function playTextDistortionShow(activeIndex: number) {
    if (!turb || !disp) {
      // Fallback: simple fade in
      const textEls = sections[activeIndex].querySelectorAll(
        ".caption, .titleRight, .index"
      );
      gsap.to(textEls, { opacity: 1, y: 0, duration: 0.4, ease: "power2.out" });
      textShown[activeIndex] = true;
      return;
    }
    const prev = activeDistortTweens.get(activeIndex);
    if (prev) prev.kill();
    // Marcar como mostrado para evitar re-disparos en frames sucesivos
    textShown[activeIndex] = true;
    const textEls = sections[activeIndex].querySelectorAll(
      ".caption, .titleRight, .index"
    );
    gsap.killTweensOf(textEls);
    textEls.forEach((el) => el.classList.add("distort"));
    const state = { scale: 46, freq: 0.09 } as { scale: number; freq: number };
    disp.setAttribute("scale", String(state.scale));
    turb.setAttribute("baseFrequency", String(state.freq));
    gsap.set(textEls, { opacity: 0, y: 8 });
    const tl = gsap
      .timeline({ defaults: { ease: "power2.out" } })
      .to(
        state,
        {
          scale: 0,
          freq: 0.02,
          duration: 0.9,
          onUpdate: () => {
            disp.setAttribute("scale", state.scale.toFixed(1));
            turb.setAttribute("baseFrequency", state.freq.toFixed(4));
          },
          onComplete: () => {
            textEls.forEach((el) => el.classList.remove("distort"));
            textShown[activeIndex] = true;
            activeDistortTweens.delete(activeIndex);
          },
        },
        0
      )
      .to(textEls, { opacity: 1, y: 0, duration: 0.6, stagger: 0.05 }, 0.05);
    activeDistortTweens.set(activeIndex, tl as unknown as gsap.core.Tween);
  }

  function playTextDistortionHide(activeIndex: number) {
    if (!turb || !disp) {
      // Fallback: simple fade out
      const textEls = sections[activeIndex].querySelectorAll(
        ".caption, .titleRight, .index"
      );
      gsap.to(textEls, { opacity: 0, y: 8, duration: 0.3, ease: "power2.in" });
      textShown[activeIndex] = false;
      return;
    }
    const prev = activeDistortTweens.get(activeIndex);
    if (prev) prev.kill();
    // Marcar como oculto para evitar re-disparos en frames sucesivos
    textShown[activeIndex] = false;
    const textEls = sections[activeIndex].querySelectorAll(
      ".caption, .titleRight, .index"
    );
    gsap.killTweensOf(textEls);
    textEls.forEach((el) => el.classList.add("distort"));
    const state = { scale: 0, freq: 0.02 } as { scale: number; freq: number };
    disp.setAttribute("scale", String(state.scale));
    turb.setAttribute("baseFrequency", String(state.freq));
    gsap.set(textEls, { opacity: 1, y: 0 });
    const tl = gsap
      .timeline({ defaults: { ease: "power2.in" } })
      .to(textEls, { opacity: 0, y: 8, duration: 0.3 }, 0)
      .to(
        state,
        {
          scale: 46,
          freq: 0.09,
          duration: 0.7,
          onUpdate: () => {
            disp.setAttribute("scale", state.scale.toFixed(1));
            turb.setAttribute("baseFrequency", state.freq.toFixed(4));
          },
          onComplete: () => {
            textEls.forEach((el) => el.classList.remove("distort"));
            textShown[activeIndex] = false;
            activeDistortTweens.delete(activeIndex);
          },
        },
        0
      );
    activeDistortTweens.set(activeIndex, tl as unknown as gsap.core.Tween);
  }

  // Posición virtual continua controlada por el "scroll" falso.
  let virtualPosition = 0; // 0 = sección 0; 1 = entre 0 y 1; etc.
  const scrollSensitivity = 0.0008; // ajusta sensibilidad según dispositivo
  const smoothDuration = 1; // suavizado del scrubbing
  const snapDelayMs = 1000; // espera antes de hacer snap
  let snapTimeout: any = null;
  let isDragging = false;
  let interactionMode: "drag" | "wheel" | null = null;
  const positionProxy = { value: 0 };

  // Estado inicial: sección 0 visible en 0%, la siguiente en 100%
  sections.forEach((el, i) => {
    gsap.set(el, { yPercent: i === 0 ? 0 : 100 });
    el.classList.toggle("visible", i === 0 || i === 1);
  });

  function syncFromProxy() {
    const base = Math.floor(positionProxy.value);
    const frac = positionProxy.value - base; // [0,1)

    const aIndex = wrapIndex(base);
    const bIndex = wrapIndex(base + 1);

    sections.forEach((el, i) => {
      el.classList.toggle("visible", i === aIndex || i === bIndex);
    });

    const a = sections[aIndex];
    const b = sections[bIndex];
    const aInner = imageInners[aIndex];
    const bInner = imageInners[bIndex];

    // Interpolación entre A (sale hacia -100%) y B (entra desde +100%)
    gsap.set(a, { yPercent: -100 * frac });
    gsap.set(b, { yPercent: 100 * (1 - frac) });

    // Parallax de imágenes: se mueven más lento que los paneles
    const parallaxFactor = 0.45; // 0..1 (menor = más lento)
    if (aInner) gsap.set(aInner, { yPercent: 100 * frac * parallaxFactor });
    if (bInner)
      gsap.set(bInner, { yPercent: -100 * (1 - frac) * parallaxFactor });

    // Evaluación por nivel de scroll: mostrar si el texto está entre 0% (abajo) y 80% (umbral) del viewport.
    const evaluateSection = (index: number) => {
      const section = sections[index];
      if (!section) return;
      // Medimos un elemento principal del texto (caption o titleRight; si no, index)
      const mainText = (section.querySelector(".caption, .titleRight") ||
        section.querySelector(".index")) as HTMLElement | null;
      if (!mainText) return;

      const rect = mainText.getBoundingClientRect();
      const vh = window.innerHeight || 1;
      const percentFromBottom = ((vh - rect.bottom) / vh) * 100; // 0% = fondo, 100% = arriba

      const shouldShow = percentFromBottom >= 0 && percentFromBottom <= 80;
      if (shouldShow && !textShown[index]) {
        playTextDistortionShow(index);
      } else if (!shouldShow && textShown[index]) {
        playTextDistortionHide(index);
      }
    };

    evaluateSection(aIndex);
    evaluateSection(bIndex);
  }

  function finalizeVisibility(targetIndex: number) {
    const index = wrapIndex(targetIndex);
    sections.forEach((el, i) => {
      const active = i === index;
      el.classList.toggle("visible", active);
      gsap.set(el, { yPercent: active ? 0 : 100 });
      const inner = imageInners[i];
      if (inner) gsap.set(inner, { yPercent: 0 });
      const texts = el.querySelectorAll(".caption, .titleRight, .index");
      gsap.set(texts, { opacity: 0, y: active ? 8 : 0 });
      if (!active) textShown[i] = false;
    });
    // Re-evaluar por nivel de scroll tras el snap (no depende del snap, sólo recalcula)
    syncFromProxy();
  }

  function scheduleSnap() {
    if (snapTimeout) clearTimeout(snapTimeout);
    // No hacer snap si estamos arrastrando activamente
    if (interactionMode === "drag" || isDragging) return;
    snapTimeout = setTimeout(() => {
      // Si nadie reinició el modo a drag, hacemos snap (caso rueda)
      if (!(interactionMode === "drag" || isDragging)) {
        snapToNearest();
      }
    }, snapDelayMs);
  }

  function snapToNearest() {
    const target = Math.round(positionProxy.value);
    virtualPosition = target;
    gsap.to(positionProxy, {
      value: target,
      duration: 1.6,
      ease: snapEase,
      overwrite: "auto",
      onUpdate: syncFromProxy,
      onComplete: () => finalizeVisibility(target),
    });
  }

  function addDelta(dy: number) {
    virtualPosition += dy * scrollSensitivity * (isDragging ? -1 : 1);
    gsap.to(positionProxy, {
      value: virtualPosition,
      duration: isDragging ? 0.4 : smoothDuration,
      ease: "power2.out",
      overwrite: "auto",
      onUpdate: syncFromProxy,
    });
    scheduleSnap();
  }

  Observer.create({
    type: "wheel,touch,pointer",
    preventDefault: true,
    ignore: ".clickable",
    onPress: () => {
      interactionMode = "drag";
      isDragging = true;
      if (snapTimeout) clearTimeout(snapTimeout);
    },
    onRelease: () => {
      isDragging = false;
      // Al soltar un drag, hacer snap inmediatamente
      interactionMode = null;
      snapToNearest();
    },
    onWheel: () => {
      // Para rueda, dejamos que el timeout dispare el snap
      interactionMode = "wheel";
    },
    onChangeY: (self) => {
      addDelta(self.deltaY);
    },
    tolerance: 10,
  });

  document.addEventListener("keydown", (e: KeyboardEvent) => {
    if (e.code === "ArrowUp" || e.code === "ArrowLeft") {
      if (snapTimeout) clearTimeout(snapTimeout);
      const target = Math.round(positionProxy.value) - 1;
      virtualPosition = target;
      gsap.to(positionProxy, {
        value: target,
        duration: 0.4,
        ease: "power2.out",
        overwrite: "auto",
        onUpdate: syncFromProxy,
        onComplete: () => finalizeVisibility(target),
      });
      return;
    }
    if (
      e.code === "ArrowDown" ||
      e.code === "ArrowRight" ||
      e.code === "Space" ||
      e.code === "Enter"
    ) {
      if (snapTimeout) clearTimeout(snapTimeout);
      const target = Math.round(positionProxy.value) + 1;
      virtualPosition = target;
      gsap.to(positionProxy, {
        value: target,
        duration: 0.4,
        ease: "power2.out",
        overwrite: "auto",
        onUpdate: syncFromProxy,
        onComplete: () => finalizeVisibility(target),
      });
      return;
    }
  });

  // Run once on load for the initial section
  requestAnimationFrame(() => {
    syncFromProxy();
  });
</script>
