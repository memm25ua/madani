---
import "../styles/global.css";
interface Project {
    name: string;
    description: string;
    image: string | null;
    thumbnail: string | null;
    url: string | null;
}
const { projects } = Astro.props as { projects: Project[] };
---

<style>
    html,
    body {
        margin: 0;
        padding: 0;
    }
    .gallery {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        position: relative;
        background: #fff;
    }
    .screen {
        position: absolute;
        inset: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: row;
        will-change: transform;
        pointer-events: none;
        visibility: hidden;
        color: #111;
        transition: flex-direction 0.3s;
    }
    .screen.reverse {
        flex-direction: row-reverse;
    }
    .visible {
        visibility: visible;
    }

    .panel {
        height: 100%;
        width: 50vw;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition:
            width 0.3s,
            height 0.3s;
    }
    .imagePanel {
        background-color: #111;
        background-size: cover;
        background-position: center;
        overflow: hidden;
    }
    .imageInner {
        position: absolute;
        inset: 0;
        background-size: cover;
        background-position: center;
        will-change: transform;
        transform: translateZ(0);
    }
    .thumbPanel {
        background: #fff;
    }

    .thumbBox {
        width: 160px;
        height: 160px;
        background: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        pointer-events: auto;
    }
    .thumbBox img {
        max-width: 80%;
        max-height: 80%;
        object-fit: contain;
    }
    .caption {
        position: absolute;
        left: 24px;
        bottom: 24px;
        font-size: 28px;
        font-weight: 600;
        letter-spacing: 0.02em;
        color: #111;
        opacity: 0;
        will-change: filter, opacity;
    }
    .index {
        position: absolute;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 22px;
        font-weight: 600;
    }
    .titleRight {
        position: absolute;
        bottom: 24px;
        right: 24px;
        font-size: 28px;
        font-weight: 600;
        opacity: 0;
        will-change: filter, opacity;
    }
    /* Distortion filter application */
    .distort {
        filter: url("#textDistortion");
    }

    /* context7: Responsive mobile styles for column layout and hide thumbnail */
    @media (max-width: 768px) {
        .screen,
        .screen.reverse {
            flex-direction: column !important;
            width: 100vw;
            height: 100vh;
        }
        .panel {
            width: 100vw;
            height: 50vh;
            min-height: 200px;
            min-width: 0;
        }
        .imagePanel {
            min-height: 40vh;
            height: 50vh;
            width: 100vw;
        }
        .thumbPanel {
            min-height: 40vh;
            height: 50vh;
            width: 100vw;
        }
        .caption,
        .titleRight {
            position: static;
            text-align: center;
            margin-top: 16px;
            margin-bottom: 0;
            left: auto;
            right: auto;
            bottom: auto;
            font-size: 22px;
        }
        .index {
            position: static;
            transform: none;
            margin-top: 8px;
            font-size: 18px;
        }
        .thumbBox {
            display: none !important;
        }
    }
</style>

<div class="gallery">
    {
        projects?.map((p, i) => {
            const bg = p.image ?? "";
            const thumb = p.thumbnail ?? "/favicon.svg";
            const isReverse = i % 2 === 1;
            return (
                <div
                    class={`screen ${i === 0 ? "visible" : ""} ${isReverse ? "reverse" : ""}`}
                    id={`screen-${i}`}
                >
                    <div class="panel imagePanel">
                        <div class="imageInner" data-bg={bg} />
                    </div>
                    <div class="panel thumbPanel">
                        <div class="thumbBox">
                            {p.url ? (
                                <a
                                    href={p.url}
                                    target="_blank"
                                    rel="noreferrer"
                                    style="pointer-events:auto;"
                                >
                                    <img
                                        src={thumb}
                                        alt={`${p.name} thumbnail`}
                                    />
                                </a>
                            ) : (
                                <img src={thumb} alt={`${p.name} thumbnail`} />
                            )}
                        </div>
                        {isReverse ? (
                            <div class="titleRight">{p.name}</div>
                        ) : (
                            <div class="caption">{p.name}</div>
                        )}
                        <div class="index">
                            {String(i + 1).padStart(2, "0")}
                        </div>
                    </div>
                </div>
            );
        })
    }
</div>

<!-- SVG filter for wave/liquid distortion -->
<svg
    xmlns="http://www.w3.org/2000/svg"
    style="position:absolute;width:0;height:0;overflow:hidden"
>
    <filter id="textDistortion" x="-20%" y="-20%" width="140%" height="140%">
        <feTurbulence
            id="td-turb"
            type="fractalNoise"
            baseFrequency="0.02"
            numOctaves="2"
            seed="2"
            result="noise"></feTurbulence>
        <feDisplacementMap
            id="td-disp"
            in="SourceGraphic"
            in2="noise"
            scale="0"
            xChannelSelector="R"
            yChannelSelector="G"></feDisplacementMap>
    </filter>
    <!-- more filters could be declared here -->
</svg>

<script>
    import { gsap } from "gsap";
    import { CustomEase } from "gsap/CustomEase";
    import { Observer } from "gsap/Observer";

    gsap.registerPlugin(Observer);
    gsap.registerPlugin(CustomEase);

    CustomEase.create("superFastSlowEnd", "M0,0 C0.1,1 0.1,1 1,1");
    // Elige aquí el ease para el snap (puedes cambiar entre superOut1..5)
    const snapEase = "expo.out";

    const sections = gsap.utils.toArray(".screen") as HTMLElement[];
    const wrapIndex = gsap.utils.wrap(0, sections.length);
    const imageInners = sections.map(
        (s) => s.querySelector(".imageInner") as HTMLElement,
    );

    // Posición virtual continua controlada por el "scroll" falso.
    let virtualPosition = 0; // 0 = sección 0; 1 = entre 0 y 1; etc.
    const scrollSensitivity = 0.0008; // ajusta sensibilidad según dispositivo
    const smoothDuration = 1.1; // suavizado del scrubbing
    const snapDelayMs = 1000; // espera antes de hacer snap
    let snapTimeout: any = null;
    let isDragging = false;
    let interactionMode: "drag" | "wheel" | null = null;
    const positionProxy = { value: 0 };

    // Lazy loading de imágenes de fondo
    let lastBase: number | null = null;

    function getBG(inner: HTMLElement): string | null {
        const url = (inner as any).dataset?.bg || null;
        return url && url.trim().length > 0 ? url : null;
    }

    function ensureImageLoaded(index: number) {
        const inner = imageInners[index];
        if (!inner) return;
        const url = getBG(inner);
        if (!url) return;

        const state = (inner as any).dataset.loaded;
        if (state === "1" || state === "loading") return;

        (inner as any).dataset.loaded = "loading";

        const img = new Image();
        img.src = url;

        const finish = () => {
            // Si se descargó durante la carga, no apliques la imagen
            if ((inner as any).dataset.loaded === "0") {
                inner.style.backgroundImage = "";
                (inner as any).dataset.loaded = "0";
                return;
            }
            inner.style.backgroundImage = `url('${url}')`;
            (inner as any).dataset.loaded = "1";
        };

        if ("decode" in img && typeof (img as any).decode === "function") {
            img.decode().then(finish).catch(finish);
        } else {
            img.onload = finish;
            img.onerror = () => {
                (inner as any).dataset.loaded = "0";
            };
        }
    }

    function unloadImage(index: number) {
        const inner = imageInners[index];
        if (!inner) return;
        if ((inner as any).dataset.loaded) {
            inner.style.backgroundImage = "";
            (inner as any).dataset.loaded = "0";
        }
    }

    function manageImages(base: number) {
        const aIndex = wrapIndex(base);
        const bIndex = wrapIndex(base + 1);
        const preIndex = wrapIndex(base + 2); // prefetch siguiente

        for (let i = 0; i < imageInners.length; i++) {
            if (i === aIndex || i === bIndex || i === preIndex) {
                ensureImageLoaded(i);
            } else {
                unloadImage(i);
            }
        }
    }

    // Configuración de ventanas de visibilidad para los textos
    const SHOW_MIN = 0; // textos visibles cuando frac ∈ [SHOW_MIN, SHOW_MAX]
    const SHOW_MAX = 0.8;

    // Referencias al filtro SVG para distorsión
    const dispEl = document.getElementById(
        "td-disp",
    ) as SVGFEDisplacementMapElement | null;
    const turbEl = document.getElementById(
        "td-turb",
    ) as SVGFETurbulenceElement | null;

    // Estado de visibilidad por elemento de texto para evitar relanzar animaciones
    const textVisible = new WeakMap<HTMLElement, boolean>();

    function getTextEl(section: HTMLElement): HTMLElement | null {
        return (
            (section.querySelector(".titleRight") as HTMLElement) ||
            (section.querySelector(".caption") as HTMLElement) ||
            null
        );
    }

    function animateEnter(el: HTMLElement) {
        // Activamos el filtro solo en este elemento
        el.classList.add("distort");
        // Valores iniciales para la distorsión
        if (dispEl) gsap.set(dispEl, { attr: { scale: 60 } });
        if (turbEl) gsap.set(turbEl, { attr: { baseFrequency: 0.02 } });
        // Animaciones combinadas: opacidad + distorsión -> a limpio
        gsap.killTweensOf(el);
        gsap.to(el, { opacity: 1, duration: 0.35, ease: "power2.out" });
        if (dispEl)
            gsap.to(dispEl, {
                attr: { scale: 0 },
                duration: 0.6,
                ease: "power3.out",
            });
        if (turbEl)
            gsap.to(turbEl, {
                attr: { baseFrequency: 0.008 },
                duration: 0.6,
                ease: "power3.out",
            });
    }

    function animateExit(el: HTMLElement) {
        // Lanzamos un pico de distorsión al ocultar
        el.classList.add("distort");
        if (dispEl) gsap.set(dispEl, { attr: { scale: 0 } });
        if (turbEl) gsap.set(turbEl, { attr: { baseFrequency: 0.012 } });
        gsap.killTweensOf(el);
        const tl = gsap.timeline({
            defaults: { ease: "power2.inOut" },
            onComplete: () => {
                el.classList.remove("distort");
            },
        });
        if (dispEl) tl.to(dispEl, { attr: { scale: 45 }, duration: 0.25 }, 0);
        tl.to(el, { opacity: 0, duration: 0.3 }, 0.05);
        if (dispEl) tl.to(dispEl, { attr: { scale: 0 }, duration: 0.3 }, 0.25);
    }

    function setTextVisibility(el: HTMLElement | null, shouldShow: boolean) {
        if (!el) return;
        const currently = textVisible.get(el) === true;
        if (shouldShow && !currently) {
            textVisible.set(el, true);
            animateEnter(el);
        } else if (!shouldShow && currently) {
            textVisible.set(el, false);
            animateExit(el);
        }
    }

    // Estado inicial: sección 0 visible en 0%, la siguiente en 100%
    sections.forEach((el, i) => {
        gsap.set(el, { yPercent: i === 0 ? 0 : 100 });
        el.classList.toggle("visible", i === 0 || i === 1);
        const textEl = getTextEl(el);
        if (textEl) {
            gsap.set(textEl, { opacity: 0 });
            textVisible.set(textEl, false);
            textEl.classList.remove("distort");
        }
    });

    function syncFromProxy() {
        const base = Math.floor(positionProxy.value);
        const frac = positionProxy.value - base; // [0,1)

        // Gestionar carga/descarga de imágenes cuando cambia la sección base
        if (lastBase !== base) {
            manageImages(base);
            lastBase = base;
        }

        const aIndex = wrapIndex(base);
        const bIndex = wrapIndex(base + 1);

        sections.forEach((el, i) => {
            el.classList.toggle("visible", i === aIndex || i === bIndex);
        });

        const a = sections[aIndex];
        const b = sections[bIndex];
        const aInner = imageInners[aIndex];
        const bInner = imageInners[bIndex];

        // Interpolación entre A (sale hacia -100%) y B (entra desde +100%)
        gsap.set(a, { yPercent: -100 * frac });
        gsap.set(b, { yPercent: 100 * (1 - frac) });

        // Parallax de imágenes: se mueven más lento que los paneles
        const parallaxFactor = 0.45; // 0..1 (menor = más lento)
        if (aInner) gsap.set(aInner, { yPercent: 100 * frac * parallaxFactor });
        if (bInner)
            gsap.set(bInner, { yPercent: -100 * (1 - frac) * parallaxFactor });

        // Mostrar/ocultar texto con animación de distorsión según el rango de frac
        const aText = getTextEl(a);
        const bText = getTextEl(b);

        const inWindow = frac >= SHOW_MIN && frac <= SHOW_MAX;

        setTextVisibility(aText, inWindow);
        setTextVisibility(bText, inWindow);
    }

    function finalizeVisibility(targetIndex: number) {
        const index = wrapIndex(targetIndex);
        sections.forEach((el, i) => {
            const active = i === index;
            el.classList.toggle("visible", active);
            gsap.set(el, { yPercent: active ? 0 : 100 });
            const inner = imageInners[i];
            if (inner) gsap.set(inner, { yPercent: 0 });
        });
        // Re-evaluar por nivel de scroll tras el snap (no depende del snap, sólo recalcula)
        syncFromProxy();
    }

    function scheduleSnap() {
        if (snapTimeout) clearTimeout(snapTimeout);
        // No hacer snap si estamos arrastrando activamente
        if (interactionMode === "drag" || isDragging) return;
        snapTimeout = setTimeout(() => {
            // Si nadie reinició el modo a drag, hacemos snap (caso rueda)
            if (!(interactionMode === "drag" || isDragging)) {
                snapToNearest();
            }
        }, snapDelayMs);
    }

    function snapToNearest() {
        const target = Math.round(positionProxy.value);
        virtualPosition = target;
        gsap.to(positionProxy, {
            value: target,
            duration: 1.2,
            ease: snapEase,
            overwrite: "auto",
            onUpdate: syncFromProxy,
            onComplete: () => finalizeVisibility(target),
        });
    }

    function addDelta(dy: number) {
        virtualPosition += dy * scrollSensitivity * (isDragging ? -1 : 1);
        gsap.to(positionProxy, {
            value: virtualPosition,
            duration: isDragging ? 0.4 : smoothDuration,
            ease: "power2.out",
            overwrite: "auto",
            onUpdate: syncFromProxy,
        });
        scheduleSnap();
    }

    Observer.create({
        type: "wheel,touch,pointer",
        preventDefault: true,
        ignore: ".clickable",
        onPress: () => {
            interactionMode = "drag";
            isDragging = true;
            if (snapTimeout) clearTimeout(snapTimeout);
        },
        onRelease: () => {
            isDragging = false;
            // Al soltar un drag, hacer snap inmediatamente
            interactionMode = null;
            snapToNearest();
        },
        onWheel: () => {
            // Para rueda, dejamos que el timeout dispare el snap
            interactionMode = "wheel";
        },
        onChangeY: (self) => {
            addDelta(self.deltaY);
        },
        tolerance: 10,
    });

    document.addEventListener("keydown", (e: KeyboardEvent) => {
        if (e.code === "ArrowUp" || e.code === "ArrowLeft") {
            if (snapTimeout) clearTimeout(snapTimeout);
            const target = Math.round(positionProxy.value) - 1;
            virtualPosition = target;
            gsap.to(positionProxy, {
                value: target,
                duration: 0.4,
                ease: "power2.out",
                overwrite: "auto",
                onUpdate: syncFromProxy,
                onComplete: () => finalizeVisibility(target),
            });
            return;
        }
        if (
            e.code === "ArrowDown" ||
            e.code === "ArrowRight" ||
            e.code === "Space" ||
            e.code === "Enter"
        ) {
            if (snapTimeout) clearTimeout(snapTimeout);
            const target = Math.round(positionProxy.value) + 1;
            virtualPosition = target;
            gsap.to(positionProxy, {
                value: target,
                duration: 0.4,
                ease: "power2.out",
                overwrite: "auto",
                onUpdate: syncFromProxy,
                onComplete: () => finalizeVisibility(target),
            });
            return;
        }
    });

    // Run once on load for the initial section
    requestAnimationFrame(() => {
        syncFromProxy();
    });
</script>
